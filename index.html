<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Symbiotic Expansion - Network Defense Game</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #000;
      color: #00ff88;
      overflow-x: hidden;
      min-height: 100vh;
      position: relative;
    }

    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: 
        radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.08) 0%, transparent 50%),
        radial-gradient(circle at 80% 70%, rgba(110, 240, 255, 0.06) 0%, transparent 50%),
        linear-gradient(180deg, #001a0d 0%, #000 100%);
      z-index: -1;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    /* Header Styles */
    .header {
      text-align: center;
      margin-bottom: 30px;
      padding: 30px 20px;
      background: linear-gradient(135deg, rgba(0, 255, 136, 0.05), rgba(0, 255, 136, 0.02));
      border-radius: 20px;
      border: 2px solid rgba(0, 255, 136, 0.2);
      box-shadow: 0 0 40px rgba(0, 255, 136, 0.1);
      animation: fadeIn 0.6s ease-out;
    }

    .header h1 {
      font-size: 3em;
      font-weight: 900;
      letter-spacing: 3px;
      text-transform: uppercase;
      background: linear-gradient(135deg, #00ff88, #6ef0ff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      text-shadow: 0 0 30px rgba(0, 255, 136, 0.5);
      margin-bottom: 10px;
      animation: glow 2s ease-in-out infinite alternate;
    }

    .header p {
      font-size: 1.1em;
      color: #5fc99d;
      letter-spacing: 1px;
    }

    /* Controls Bar */
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 15px;
      margin-bottom: 25px;
      padding: 20px;
      background: rgba(0, 26, 13, 0.6);
      border-radius: 15px;
      border: 1px solid rgba(0, 255, 136, 0.15);
      flex-wrap: wrap;
      backdrop-filter: blur(10px);
    }

    .controls-left {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .controls-right {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    input {
      padding: 12px 16px;
      background: rgba(0, 0, 0, 0.6);
      border: 2px solid rgba(0, 255, 136, 0.3);
      border-radius: 10px;
      color: #00ff88;
      font-size: 14px;
      outline: none;
      transition: all 0.3s;
      min-width: 180px;
    }

    input:focus {
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.3);
    }

    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, #00ff88, #00cc6f);
      border: none;
      border-radius: 10px;
      color: #001a0d;
      font-weight: 800;
      font-size: 14px;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(0, 255, 136, 0.5);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    button.secondary {
      background: transparent;
      border: 2px solid #00ff88;
      color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.2);
    }

    button.secondary:hover {
      background: rgba(0, 255, 136, 0.1);
    }

    /* Game Layout */
    .game-layout {
      display: grid;
      grid-template-columns: 1fr 320px;
      gap: 25px;
      animation: fadeIn 0.8s ease-out 0.2s backwards;
    }

    /* Canvas Container */
    .canvas-container {
      position: relative;
      background: linear-gradient(135deg, rgba(0, 26, 13, 0.4), rgba(0, 13, 26, 0.4));
      border-radius: 20px;
      padding: 20px;
      border: 2px solid rgba(0, 255, 136, 0.2);
      box-shadow: 
        0 0 40px rgba(0, 255, 136, 0.15),
        inset 0 0 60px rgba(0, 0, 0, 0.5);
    }

    canvas {
      width: 100%;
      height: 600px;
      border-radius: 15px;
      background: linear-gradient(135deg, #001a0d, #000d1a);
      box-shadow: inset 0 0 50px rgba(0, 0, 0, 0.8);
      cursor: crosshair;
    }

    /* Stats Panel */
    .stats-panel {
      background: linear-gradient(135deg, rgba(0, 26, 13, 0.6), rgba(0, 13, 26, 0.6));
      border-radius: 20px;
      padding: 25px;
      border: 2px solid rgba(0, 255, 136, 0.2);
      box-shadow: 0 0 30px rgba(0, 255, 136, 0.1);
      backdrop-filter: blur(10px);
      height: fit-content;
    }

    .stats-panel h2 {
      font-size: 1.5em;
      margin-bottom: 20px;
      color: #00ff88;
      text-align: center;
      text-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px;
      margin-bottom: 12px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 12px;
      border: 1px solid rgba(0, 255, 136, 0.15);
      transition: all 0.3s;
    }

    .stat-item:hover {
      border-color: rgba(0, 255, 136, 0.4);
      background: rgba(0, 0, 0, 0.6);
    }

    .stat-label {
      color: #5fc99d;
      font-size: 0.95em;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .stat-value {
      font-size: 1.8em;
      font-weight: 900;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
    }

    .stat-value.highlight {
      color: #6ef0ff;
      text-shadow: 0 0 10px rgba(110, 240, 255, 0.6);
    }

    /* Instructions */
    .instructions {
      margin-top: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.4);
      border-radius: 12px;
      border: 1px solid rgba(0, 255, 136, 0.15);
    }

    .instructions h3 {
      color: #00ff88;
      margin-bottom: 12px;
      font-size: 1.1em;
    }

    .instructions p {
      color: #5fc99d;
      font-size: 0.9em;
      line-height: 1.6;
      margin-bottom: 8px;
    }

    .instructions strong {
      color: #00ff88;
      font-weight: 800;
    }

    .color-legend {
      display: flex;
      gap: 15px;
      margin-top: 12px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      box-shadow: 0 0 10px currentColor;
    }

    .legend-color.good {
      background: #00ff88;
    }

    .legend-color.bad {
      background: #ff4a4a;
    }

    /* Modal Overlay */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(8px);
      z-index: 1000;
      align-items: center;
      justify-content: center;
      animation: fadeIn 0.3s ease-out;
    }

    .modal-overlay.active {
      display: flex;
    }

    .modal {
      background: linear-gradient(135deg, rgba(0, 26, 13, 0.95), rgba(0, 13, 26, 0.95));
      padding: 40px;
      border-radius: 20px;
      border: 2px solid rgba(0, 255, 136, 0.4);
      box-shadow: 0 0 60px rgba(0, 255, 136, 0.3);
      text-align: center;
      max-width: 500px;
      animation: scaleIn 0.4s ease-out;
    }

    .modal h2 {
      font-size: 2.5em;
      color: #00ff88;
      margin-bottom: 15px;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.6);
    }

    .modal p {
      font-size: 1.2em;
      color: #5fc99d;
      margin-bottom: 10px;
    }

    .modal .score {
      font-size: 2em;
      font-weight: 900;
      color: #6ef0ff;
      margin: 20px 0;
      text-shadow: 0 0 15px rgba(110, 240, 255, 0.6);
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.8);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes glow {
      from {
        filter: drop-shadow(0 0 20px rgba(0, 255, 136, 0.4));
      }
      to {
        filter: drop-shadow(0 0 30px rgba(0, 255, 136, 0.8));
      }
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .game-layout {
        grid-template-columns: 1fr;
      }

      .stats-panel {
        max-width: 100%;
      }

      canvas {
        height: 500px;
      }
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2em;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .controls-left,
      .controls-right {
        width: 100%;
        justify-content: center;
      }

      input {
        width: 100%;
      }

      canvas {
        height: 400px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>âš¡ Symbiotic Expansion âš¡</h1>
      <p>Defend your network core â€¢ Connect modules â€¢ Survive the corruption waves</p>
    </div>

    <div class="controls">
      <div class="controls-left">
        <input type="text" id="username" placeholder="Enter your username" />
        <button onclick="saveUsername()">Save Name</button>
      </div>
      <div class="controls-right">
        <button id="autoConnectBtn" class="secondary" onclick="toggleAutoConnect()">
          Auto-Connect: OFF
        </button>
        <button id="startBtn" onclick="startWave()">Start Game</button>
      </div>
    </div>

    <div class="game-layout">
      <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div class="stats-panel">
        <h2>âš¡ Stats âš¡</h2>
        
        <div class="stat-item">
          <span class="stat-label">Player</span>
          <span class="stat-value" id="playerName">â€”</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">XP</span>
          <span class="stat-value highlight" id="xp">0</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">High Score</span>
          <span class="stat-value" id="highScore">0</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">Wave</span>
          <span class="stat-value" id="wave">0</span>
        </div>

        <div class="instructions">
          <h3>ðŸŽ® Controls</h3>
          <p><strong>WASD</strong> or <strong>Arrow Keys</strong> - Move your core</p>
          <p><strong>SPACE</strong> or <strong>Click</strong> - Connect to module</p>
          
          <div class="color-legend">
            <div class="legend-item">
              <div class="legend-color good"></div>
              <span>Good Module (+50 XP)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color bad"></div>
              <span>Corrupted (-30 XP)</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div class="modal-overlay" id="gameOverModal">
    <div class="modal">
      <h2>ðŸ’€ Network Breached</h2>
      <p>Your core has been corrupted!</p>
      <div class="score">XP: <span id="finalXP">0</span></div>
      <p>Wave: <span id="finalWave">0</span></p>
      <button onclick="resetGame()" style="margin-top: 20px; width: 100%;">
        ðŸ”„ Try Again
      </button>
    </div>
  </div>

  <!-- Supabase Client -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    const SUPABASE_URL = 'https://mapbotiiklwzulbdwnyt.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1hcGJvdGlpa2x3enVsYmR3bnl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk2NDUxMDksImV4cCI6MjA3NTIyMTEwOX0.uh1YxIssy13LsLlA7AOAYsMqNyuzGanPxMMNylWAoRU';
    
    window.supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

    // Game State
    const game = {
      canvas: null,
      ctx: null,
      player: { x: 100, y: 100, r: 14, speed: 240 },
      modules: [],
      moduleId: 0,
      keys: {},
      running: false,
      xp: 0,
      highScore: 0,
      wave: 0,
      autoConnect: false,
      username: localStorage.getItem('symbio_user') || '',
      spawnTimer: 0,
      spawnInterval: 900,
      modulesThisWave: 0,
      waveTarget: 12,
      lastTime: performance.now()
    };

    const COLORS = {
      good: '#00ff88',
      bad: '#ff4a4a',
      core: '#6ef0ff',
      bg: '#001a0d'
    };

    const CONNECT_DIST = 50;
    const COLLIDE_DIST = 20;
    const XP_GAIN = 50;
    const XP_LOSS = 30;

    // Initialize
    window.addEventListener('load', () => {
      game.canvas = document.getElementById('gameCanvas');
      game.ctx = game.canvas.getContext('2d');
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Load username
      if (game.username) {
        document.getElementById('username').value = game.username;
        document.getElementById('playerName').textContent = game.username;
        loadHighScore();
      }

      // Input handlers
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      game.canvas.addEventListener('click', handleCanvasClick);

      // Start game loop
      requestAnimationFrame(gameLoop);
    });

    function resizeCanvas() {
      const container = game.canvas.parentElement;
      game.canvas.width = container.clientWidth - 40;
      game.canvas.height = 600;
    }

    // Save username
    window.saveUsername = function() {
      const username = document.getElementById('username').value.trim();
      if (!username) {
        alert('Please enter a username!');
        return;
      }
      game.username = username;
      localStorage.setItem('symbio_user', username);
      document.getElementById('playerName').textContent = username;
      loadHighScore();
    };

    // Load high score
    async function loadHighScore() {
      if (!game.username) return;
      try {
        const { data } = await window.supabase
          .from('symbiotic_scores')
          .select('xp')
          .eq('username', game.username)
          .order('xp', { ascending: false })
          .limit(1);

        if (data && data.length > 0) {
          game.highScore = data[0].xp;
          document.getElementById('highScore').textContent = game.highScore;
        }
      } catch (error) {
        console.error('Error loading high score:', error);
      }
    }

    // Save score
    async function saveScore() {
      if (!game.username || game.xp <= game.highScore) return;
      try {
        await window.supabase
          .from('symbiotic_scores')
          .insert([{ username: game.username, xp: game.xp, wave: game.wave }]);
        
        game.highScore = game.xp;
        document.getElementById('highScore').textContent = game.highScore;
      } catch (error) {
        console.error('Error saving score:', error);
      }
    }

    // Start wave
    window.startWave = function() {
      if (game.running) return;
      game.running = true;
      game.wave++;
      document.getElementById('wave').textContent = game.wave;
      document.getElementById('startBtn').disabled = true;
      document.getElementById('startBtn').textContent = 'Playing...';
      
      game.spawnInterval = Math.max(400, 900 - game.wave * 60);
      game.modulesThisWave = 0;
      game.waveTarget = 10 + Math.floor(game.wave * 1.4);
      game.spawnTimer = 0;
    };

    // Toggle auto-connect
    window.toggleAutoConnect = function() {
      game.autoConnect = !game.autoConnect;
      const btn = document.getElementById('autoConnectBtn');
      btn.textContent = game.autoConnect ? 'Auto-Connect: ON' : 'Auto-Connect: OFF';
    };

    // Reset game
    window.resetGame = function() {
      game.xp = 0;
      game.wave = 0;
      game.running = false;
      game.modules = [];
      game.moduleId = 0;
      game.player = { x: 100, y: 100, r: 14, speed: 240 };
      
      document.getElementById('xp').textContent = '0';
      document.getElementById('wave').textContent = '0';
      document.getElementById('startBtn').disabled = false;
      document.getElementById('startBtn').textContent = 'Start Game';
      document.getElementById('gameOverModal').classList.remove('active');
    };

    // Spawn module
    function spawnModule() {
      const side = Math.random();
      let x, y, vx, vy;

      if (side < 0.25) {
        x = -20;
        y = Math.random() * (game.canvas.height - 80) + 40;
        vx = Math.random() * 0.8 + 0.4;
        vy = Math.random() * 0.6 - 0.3;
      } else if (side < 0.5) {
        x = Math.random() * (game.canvas.width - 80) + 40;
        y = -20;
        vx = Math.random() - 0.5;
        vy = Math.random() * 0.8 + 0.4;
      } else if (side < 0.75) {
        x = game.canvas.width + 20;
        y = Math.random() * (game.canvas.height - 80) + 40;
        vx = -(Math.random() * 0.8 + 0.4);
        vy = Math.random() * 0.6 - 0.3;
      } else {
        x = Math.random() * (game.canvas.width - 80) + 40;
        y = game.canvas.height + 20;
        vx = Math.random() - 0.5;
        vy = -(Math.random() * 0.8 + 0.4);
      }

      const badChance = Math.min(0.08 + game.wave * 0.02 + Math.random() * 0.1, 0.6);
      const type = Math.random() < badChance ? 'bad' : 'good';

      game.modules.push({
        id: ++game.moduleId,
        x, y, vx, vy, type,
        connected: false
      });
      game.modulesThisWave++;
    }

    // Try to connect to module
    function tryConnect(module) {
      if (module.connected) return;

      const dist = Math.hypot(module.x - game.player.x, module.y - game.player.y);
      if (dist > CONNECT_DIST * 2 && !game.autoConnect) return;

      if (module.type === 'good') {
        module.connected = true;
        game.xp += XP_GAIN;
        document.getElementById('xp').textContent = game.xp;
        
        setTimeout(() => {
          const idx = game.modules.findIndex(m => m.id === module.id);
          if (idx >= 0) game.modules.splice(idx, 1);
        }, 200);
      } else {
        game.xp -= XP_LOSS;
        document.getElementById('xp').textContent = game.xp;
        
        if (game.xp < 0) {
          endGame();
          return;
        }
        
        setTimeout(() => {
          const idx = game.modules.findIndex(m => m.id === module.id);
          if (idx >= 0) game.modules.splice(idx, 1);
        }, 200);
      }
    }

    // Check collisions
    function checkCollisions() {
      for (let i = game.modules.length - 1; i >= 0; i--) {
        const m = game.modules[i];
        if (m.type === 'bad') {
          const dist = Math.hypot(m.x - game.player.x, m.y - game.player.y);
          if (dist < COLLIDE_DIST + game.player.r) {
            game.xp -= XP_LOSS;
            document.getElementById('xp').textContent = game.xp;
            game.modules.splice(i, 1);
            
            if (game.xp < 0) {
              endGame();
            }
          }
        }
      }
    }

    // End game
    function endGame() {
      game.running = false;
      document.getElementById('finalXP').textContent = game.xp;
      document.getElementById('finalWave').textContent = game.wave;
      document.getElementById('gameOverModal').classList.add('active');
      document.getElementById('startBtn').disabled = false;
      document.getElementById('startBtn').textContent = 'Start Game';
      saveScore();
    }

    // Input handlers
    function handleKeyDown(e) {
      game.keys[e.key.toLowerCase()] = true;
      if (e.code === 'Space') {
        e.preventDefault();
        connectNearby();
      }
    }

    function handleKeyUp(e) {
      game.keys[e.key.toLowerCase()] = false;
    }

    function handleCanvasClick(e) {
      const rect = game.canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (game.canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (game.canvas.height / rect.height);

      let nearest = null;
      let bestDist = 9999;

      for (const m of game.modules) {
        const d = Math.hypot(m.x - mx, m.y - my);
        if (d < bestDist) {
          bestDist = d;
          nearest = m;
        }
      }

      if (nearest && bestDist < 70) {
        tryConnect(nearest);
      }
    }

    function connectNearby() {
      let nearest = null;
      let bestDist = 9999;

      for (const m of game.modules) {
        if (m.connected) continue;
        const d = Math.hypot(m.x - game.player.x, m.y - game.player.y);
        if (d < bestDist) {
          bestDist = d;
          nearest = m;
        }
      }

      if (nearest && bestDist <= CONNECT_DIST * 2) {
        tryConnect(nearest);
      }
    }

    // Game loop
    function gameLoop(now) {
      const dt = (now - game.lastTime) / 1000;
      game.lastTime = now;

      // Move player
      let vx = 0, vy = 0;
      if (game.keys['arrowleft'] || game.keys['a']) vx = -1;
      if (game.keys['arrowright'] || game.keys['d']) vx = 1;
      if (game.keys['arrowup'] || game.keys['w']) vy = -1;
      if (game.keys['arrowdown'] || game.keys['s']) vy = 1;

      if (vx || vy) {
        const len = Math.hypot(vx, vy) || 1;
        game.player.x += (vx / len) * game.player.speed * dt;
        game.player.y += (vy / len) * game.player.speed * dt;
        game.player.x = Math.max(20, Math.min(game.canvas.width - 20, game.player.x));
        game.player.y = Math.max(20, Math.min(game.canvas.height - 20, game.player.y));
      }

      // Spawn modules
      if (game.running && game.modulesThisWave < game.waveTarget) {
        game.spawnTimer += dt * 1000;
        if (game.spawnTimer >= game.spawnInterval) {
          spawnModule();
          game.spawnTimer = 0;
        }
      }

      // Update modules
      for (const m of game.modules) {
        m.x += m.vx * (50 + game.wave * 6) * dt;
        m.y += m.vy * (50 + game.wave * 4) * dt;
        m.vx += (Math.random() - 0.5) * 0.04;
        m.vy += (Math.random() - 0.5) * 0.04;
      }

      // Auto-connect
      if (game.autoConnect) {
        for (const m of game.modules) {
          if (!m.connected && m.type === 'good') {
            const d = Math.hypot(m.x - game.player.x, m.y - game.player.y);
            if (d < CONNECT_DIST + 6) tryConnect(m);
          }
        }
      }

      // Check collisions
      checkCollisions();

      // Clean up distant modules
      game.modules = game.modules.filter(m =>
        m.x > -80 && m.x < game.canvas.width + 80 &&
        m.y > -80 && m.y < game.canvas.height + 80
      );

      // Check wave completion
      if (game.running && game.modulesThisWave >= game.waveTarget && game.modules.length === 0) {
        game.running = false;
        game.xp += 20 + game.wave * 3;
        document.getElementById('xp').textContent = game.xp;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('startBtn').textContent = 'Next Wave';
        saveScore();
      }

      // Draw
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Draw game
    function draw() {
      const ctx = game.ctx;
      const canvas = game.canvas;

      // Background
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.06)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw modules
      for (const m of game.modules) {
        if (m.connected) continue;

        // Outer glow
        ctx.beginPath();
        ctx.fillStyle = m.type === 'good' ? COLORS.good : COLORS.bad;
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.arc(m.x, m.y, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Inner circle
        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.arc(m.x, m.y, 8, 0, Math.PI * 2);
        ctx.fill();

        // Symbol
        ctx.fillStyle = m.type === 'good' ? COLORS.good : COLORS.bad;
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(m.type === 'good' ? '+' : '!', m.x, m.y);
      }

      // Draw player core
      const p = game.player;
      ctx.beginPath();
      ctx.fillStyle = COLORS.core;
      ctx.shadowColor = COLORS.core;
      ctx.shadowBlur = 30;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner core
      ctx.beginPath();
      ctx.fillStyle = '#000';
      ctx.arc(p.x, p.y, p.r * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
  </script>
</body>
</html>
