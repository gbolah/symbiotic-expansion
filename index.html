<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Symbiotic Expansion - Network Defense Game</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Orbitron', monospace;
      background: #0a0a0a;
      color: #00ff88;
      overflow-x: hidden;
      min-height: 100vh;
      position: relative;
    }

    /* Animated Hexagon Background Pattern */
    body::before {
      content: '';
      position: fixed;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background-image: 
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0, 255, 136, 0.03) 2px, rgba(0, 255, 136, 0.03) 4px),
        repeating-linear-gradient(60deg, transparent, transparent 2px, rgba(0, 255, 136, 0.03) 2px, rgba(0, 255, 136, 0.03) 4px),
        repeating-linear-gradient(120deg, transparent, transparent 2px, rgba(0, 255, 136, 0.03) 2px, rgba(0, 255, 136, 0.03) 4px);
      animation: bgRotate 60s linear infinite;
      z-index: -2;
    }

    /* Scanline Effect */
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(0, 255, 136, 0.02) 2px,
        rgba(0, 255, 136, 0.02) 4px
      );
      pointer-events: none;
      z-index: 9999;
      animation: scanline 8s linear infinite;
    }

    @keyframes bgRotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    @keyframes scanline {
      0% { transform: translateY(0); }
      100% { transform: translateY(100%); }
    }

    .container {
      max-width: 1600px;
      margin: 0 auto;
      padding: 15px;
      position: relative;
    }

    /* Cyber Header with Glitch Effect */
    .header {
      text-align: center;
      margin-bottom: 20px;
      padding: 25px;
      background: #000;
      clip-path: polygon(0 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%);
      border: 2px solid #00ff88;
      position: relative;
      overflow: hidden;
    }

    .header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(0, 255, 136, 0.2), transparent);
      animation: scan 3s infinite;
    }

    @keyframes scan {
      0%, 100% { left: -100%; }
      50% { left: 100%; }
    }

    .header h1 {
      font-size: 2.8em;
      font-weight: 900;
      letter-spacing: 8px;
      text-transform: uppercase;
      color: #00ff88;
      text-shadow: 
        0 0 5px #00ff88,
        0 0 10px #00ff88,
        0 0 20px #00ff88,
        0 0 40px #00ff88;
      margin-bottom: 8px;
      animation: flicker 4s infinite alternate;
      position: relative;
    }

    @keyframes flicker {
      0%, 18%, 22%, 25%, 53%, 57%, 100% {
        text-shadow: 
          0 0 5px #00ff88,
          0 0 10px #00ff88,
          0 0 20px #00ff88,
          0 0 40px #00ff88;
      }
      20%, 24%, 55% {
        text-shadow: none;
      }
    }

    .header p {
      font-size: 0.9em;
      color: #00ff88;
      letter-spacing: 3px;
      opacity: 0.7;
      font-weight: 400;
    }

    /* Angular Control Bar */
    .controls {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
      margin-bottom: 20px;
      padding: 15px;
      background: linear-gradient(135deg, #0a0a0a, #000);
      clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
      border: 1px solid #00ff88;
      flex-wrap: wrap;
      position: relative;
    }

    .controls::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      border: 1px solid #00ff88;
      clip-path: polygon(10px 0, 100% 0, 100% calc(100% - 10px), calc(100% - 10px) 100%, 0 100%, 0 10px);
      opacity: 0.3;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }

    .controls-left, .controls-right {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    input {
      padding: 10px 14px;
      background: #000;
      border: 2px solid #00ff88;
      color: #00ff88;
      font-size: 13px;
      font-family: 'Orbitron', monospace;
      outline: none;
      transition: all 0.3s;
      min-width: 180px;
      clip-path: polygon(5px 0, 100% 0, 100% calc(100% - 5px), calc(100% - 5px) 100%, 0 100%, 0 5px);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    input:focus {
      box-shadow: 
        inset 0 0 10px rgba(0, 255, 136, 0.3),
        0 0 15px rgba(0, 255, 136, 0.5);
    }

    button {
      padding: 10px 20px;
      background: #00ff88;
      border: 2px solid #00ff88;
      color: #000;
      font-weight: 700;
      font-size: 12px;
      font-family: 'Orbitron', monospace;
      cursor: pointer;
      transition: all 0.3s;
      text-transform: uppercase;
      letter-spacing: 2px;
      clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
      position: relative;
      overflow: hidden;
    }

    button::before {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 0;
      height: 0;
      background: rgba(255, 255, 255, 0.3);
      transform: translate(-50%, -50%);
      transition: width 0.3s, height 0.3s;
    }

    button:hover::before {
      width: 300px;
      height: 300px;
    }

    button:hover {
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(0);
    }

    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    button.secondary {
      background: #000;
      color: #00ff88;
    }

    /* Game Layout */
    .game-layout {
      display: grid;
      grid-template-columns: 1fr 340px;
      gap: 20px;
    }

    /* Canvas Container with Circuit Board Style */
    .canvas-container {
      position: relative;
      background: #000;
      padding: 3px;
      clip-path: polygon(15px 0, 100% 0, 100% calc(100% - 15px), calc(100% - 15px) 100%, 0 100%, 0 15px);
      border: 3px solid #00ff88;
      box-shadow: 
        inset 0 0 30px rgba(0, 255, 136, 0.2),
        0 0 30px rgba(0, 255, 136, 0.3);
    }

    /* Corner Decorations */
    .canvas-container::before,
    .canvas-container::after {
      content: '';
      position: absolute;
      width: 20px;
      height: 20px;
      border: 3px solid #00ff88;
      z-index: 10;
    }

    .canvas-container::before {
      top: -3px;
      left: -3px;
      border-right: none;
      border-bottom: none;
    }

    .canvas-container::after {
      bottom: -3px;
      right: -3px;
      border-left: none;
      border-top: none;
    }

    canvas {
      width: 100%;
      height: 600px;
      display: block;
      background: 
        radial-gradient(circle at 30% 40%, rgba(0, 255, 136, 0.05), transparent 50%),
        #000;
      cursor: crosshair;
    }

    /* Stats Panel - Hexagonal Style */
    .stats-panel {
      background: #000;
      padding: 20px;
      clip-path: polygon(12px 0, 100% 0, 100% calc(100% - 12px), calc(100% - 12px) 100%, 0 100%, 0 12px);
      border: 2px solid #00ff88;
      box-shadow: 
        inset 0 0 20px rgba(0, 255, 136, 0.1),
        0 0 20px rgba(0, 255, 136, 0.2);
      height: fit-content;
      position: relative;
    }

    .stats-panel h2 {
      font-size: 1.4em;
      margin-bottom: 18px;
      color: #00ff88;
      text-align: center;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.8);
      letter-spacing: 4px;
      border-bottom: 2px solid #00ff88;
      padding-bottom: 10px;
    }

    .stat-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      margin-bottom: 10px;
      background: rgba(0, 255, 136, 0.05);
      clip-path: polygon(6px 0, 100% 0, 100% calc(100% - 6px), calc(100% - 6px) 100%, 0 100%, 0 6px);
      border-left: 3px solid #00ff88;
      transition: all 0.3s;
      position: relative;
    }

    .stat-item::after {
      content: '';
      position: absolute;
      right: 0;
      top: 0;
      width: 0;
      height: 100%;
      background: rgba(0, 255, 136, 0.1);
      transition: width 0.3s;
    }

    .stat-item:hover::after {
      width: 100%;
    }

    .stat-item:hover {
      background: rgba(0, 255, 136, 0.1);
    }

    .stat-label {
      color: #00ff88;
      font-size: 0.85em;
      text-transform: uppercase;
      letter-spacing: 2px;
      font-weight: 700;
      z-index: 1;
    }

    .stat-value {
      font-size: 1.6em;
      font-weight: 900;
      color: #00ff88;
      text-shadow: 0 0 8px rgba(0, 255, 136, 0.8);
      z-index: 1;
    }

    .stat-value.highlight {
      color: #0ff;
      text-shadow: 0 0 8px rgba(0, 255, 255, 0.8);
      animation: valueGlow 1.5s infinite alternate;
    }

    @keyframes valueGlow {
      0% { text-shadow: 0 0 8px rgba(0, 255, 255, 0.8); }
      100% { text-shadow: 0 0 15px rgba(0, 255, 255, 1); }
    }

    /* Instructions */
    .instructions {
      margin-top: 15px;
      padding: 15px;
      background: rgba(0, 255, 136, 0.03);
      clip-path: polygon(8px 0, 100% 0, 100% calc(100% - 8px), calc(100% - 8px) 100%, 0 100%, 0 8px);
      border: 1px solid rgba(0, 255, 136, 0.3);
    }

    .instructions h3 {
      color: #00ff88;
      margin-bottom: 10px;
      font-size: 1em;
      letter-spacing: 2px;
      text-transform: uppercase;
    }

    .instructions p {
      color: rgba(0, 255, 136, 0.8);
      font-size: 0.75em;
      line-height: 1.5;
      margin-bottom: 6px;
      letter-spacing: 1px;
    }

    .instructions strong {
      color: #00ff88;
      font-weight: 700;
    }

    .color-legend {
      display: flex;
      gap: 12px;
      margin-top: 10px;
      flex-wrap: wrap;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 0.75em;
    }

    .legend-color {
      width: 16px;
      height: 16px;
      clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
      box-shadow: 0 0 8px currentColor;
    }

    .legend-color.good {
      background: #00ff88;
    }

    .legend-color.bad {
      background: #ff1744;
    }

    /* Modal with Digital Glitch */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.95);
      z-index: 1000;
      align-items: center;
      justify-content: center;
    }

    .modal-overlay.active {
      display: flex;
      animation: fadeIn 0.3s;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .modal {
      background: #000;
      padding: 40px;
      clip-path: polygon(20px 0, 100% 0, 100% calc(100% - 20px), calc(100% - 20px) 100%, 0 100%, 0 20px);
      border: 3px solid #00ff88;
      box-shadow: 
        inset 0 0 40px rgba(0, 255, 136, 0.2),
        0 0 50px rgba(0, 255, 136, 0.5);
      text-align: center;
      max-width: 500px;
      animation: glitchIn 0.5s;
      position: relative;
    }

    @keyframes glitchIn {
      0% { 
        transform: scale(0.9) translateX(-10px);
        opacity: 0;
      }
      20% { transform: scale(1.05) translateX(10px); }
      40% { transform: scale(0.95) translateX(-5px); }
      60% { transform: scale(1.02) translateX(5px); }
      100% { 
        transform: scale(1) translateX(0);
        opacity: 1;
      }
    }

    .modal h2 {
      font-size: 2.5em;
      color: #00ff88;
      margin-bottom: 15px;
      text-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
      letter-spacing: 5px;
    }

    .modal p {
      font-size: 1.1em;
      color: rgba(0, 255, 136, 0.9);
      margin-bottom: 10px;
      letter-spacing: 2px;
    }

    .modal .score {
      font-size: 2.2em;
      font-weight: 900;
      color: #0ff;
      margin: 20px 0;
      text-shadow: 0 0 15px rgba(0, 255, 255, 0.8);
      letter-spacing: 3px;
    }

    /* Responsive Design */
    @media (max-width: 1200px) {
      .game-layout {
        grid-template-columns: 1fr;
      }

      canvas {
        height: 500px;
      }
    }

    @media (max-width: 768px) {
      .header h1 {
        font-size: 2em;
        letter-spacing: 4px;
      }

      .controls {
        flex-direction: column;
        align-items: stretch;
      }

      .controls-left,
      .controls-right {
        width: 100%;
        justify-content: center;
      }

      input {
        width: 100%;
      }

      canvas {
        height: 400px;
      }

      button {
        width: 100%;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>âš¡ Symbiotic Expansion âš¡</h1>
      <p>Defend your network core â€¢ Connect modules â€¢ Survive the corruption waves</p>
    </div>

    <div class="controls">
      <div class="controls-left">
        <input type="text" id="username" placeholder="Enter your username" />
        <button onclick="saveUsername()">Save Name</button>
      </div>
      <div class="controls-right">
        <button id="autoConnectBtn" class="secondary" onclick="toggleAutoConnect()">
          Auto-Connect: OFF
        </button>
        <button id="startBtn" onclick="startWave()">Start Game</button>
      </div>
    </div>

    <div class="game-layout">
      <div class="canvas-container">
        <canvas id="gameCanvas"></canvas>
      </div>

      <div class="stats-panel">
        <h2>âš¡ Stats âš¡</h2>
        
        <div class="stat-item">
          <span class="stat-label">Player</span>
          <span class="stat-value" id="playerName">â€”</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">XP</span>
          <span class="stat-value highlight" id="xp">0</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">High Score</span>
          <span class="stat-value" id="highScore">0</span>
        </div>

        <div class="stat-item">
          <span class="stat-label">Wave</span>
          <span class="stat-value" id="wave">0</span>
        </div>

        <div class="instructions">
          <h3>ðŸŽ® Controls</h3>
          <p><strong>WASD</strong> or <strong>Arrow Keys</strong> - Move your core</p>
          <p><strong>SPACE</strong> or <strong>Click</strong> - Connect to module</p>
          
          <div class="color-legend">
            <div class="legend-item">
              <div class="legend-color good"></div>
              <span>Good Module (+50 XP)</span>
            </div>
            <div class="legend-item">
              <div class="legend-color bad"></div>
              <span>Corrupted (-30 XP)</span>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Game Over Modal -->
  <div class="modal-overlay" id="gameOverModal">
    <div class="modal">
      <h2>ðŸ’€ Network Breached</h2>
      <p>Your core has been corrupted!</p>
      <div class="score">XP: <span id="finalXP">0</span></div>
      <p>Wave: <span id="finalWave">0</span></p>
      <button onclick="resetGame()" style="margin-top: 20px; width: 100%;">
        ðŸ”„ Try Again
      </button>
    </div>
  </div>

  <!-- Supabase Client -->
  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm';

    const SUPABASE_URL = 'https://mapbotiiklwzulbdwnyt.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im1hcGJvdGlpa2x3enVsYmR3bnl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk2NDUxMDksImV4cCI6MjA3NTIyMTEwOX0.uh1YxIssy13LsLlA7AOAYsMqNyuzGanPxMMNylWAoRU';
    
    window.supabase = createClient(SUPABASE_URL, SUPABASE_KEY);

    // Game State
    const game = {
      canvas: null,
      ctx: null,
      player: { x: 100, y: 100, r: 14, speed: 240 },
      modules: [],
      moduleId: 0,
      keys: {},
      running: false,
      xp: 0,
      highScore: 0,
      wave: 0,
      autoConnect: false,
      username: localStorage.getItem('symbio_user') || '',
      spawnTimer: 0,
      spawnInterval: 900,
      modulesThisWave: 0,
      waveTarget: 12,
      lastTime: performance.now()
    };

    const COLORS = {
      good: '#00ff88',
      bad: '#ff4a4a',
      core: '#6ef0ff',
      bg: '#001a0d'
    };

    const CONNECT_DIST = 50;
    const COLLIDE_DIST = 20;
    const XP_GAIN = 50;
    const XP_LOSS = 30;

    // Initialize
    window.addEventListener('load', () => {
      game.canvas = document.getElementById('gameCanvas');
      game.ctx = game.canvas.getContext('2d');
      
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);
      
      // Load username
      if (game.username) {
        document.getElementById('username').value = game.username;
        document.getElementById('playerName').textContent = game.username;
        loadHighScore();
      }

      // Input handlers
      window.addEventListener('keydown', handleKeyDown);
      window.addEventListener('keyup', handleKeyUp);
      game.canvas.addEventListener('click', handleCanvasClick);

      // Start game loop
      requestAnimationFrame(gameLoop);
    });

    function resizeCanvas() {
      const container = game.canvas.parentElement;
      game.canvas.width = container.clientWidth - 40;
      game.canvas.height = 600;
    }

    // Save username
    window.saveUsername = function() {
      const username = document.getElementById('username').value.trim();
      if (!username) {
        alert('Please enter a username!');
        return;
      }
      game.username = username;
      localStorage.setItem('symbio_user', username);
      document.getElementById('playerName').textContent = username;
      loadHighScore();
    };

    // Load high score
    async function loadHighScore() {
      if (!game.username) return;
      try {
        const { data } = await window.supabase
          .from('symbiotic_scores')
          .select('xp')
          .eq('username', game.username)
          .order('xp', { ascending: false })
          .limit(1);

        if (data && data.length > 0) {
          game.highScore = data[0].xp;
          document.getElementById('highScore').textContent = game.highScore;
        }
      } catch (error) {
        console.error('Error loading high score:', error);
      }
    }

    // Save score
    async function saveScore() {
      if (!game.username || game.xp <= game.highScore) return;
      try {
        await window.supabase
          .from('symbiotic_scores')
          .insert([{ username: game.username, xp: game.xp, wave: game.wave }]);
        
        game.highScore = game.xp;
        document.getElementById('highScore').textContent = game.highScore;
      } catch (error) {
        console.error('Error saving score:', error);
      }
    }

    // Start wave
    window.startWave = function() {
      if (game.running) return;
      game.running = true;
      game.wave++;
      document.getElementById('wave').textContent = game.wave;
      document.getElementById('startBtn').disabled = true;
      document.getElementById('startBtn').textContent = 'Playing...';
      
      game.spawnInterval = Math.max(400, 900 - game.wave * 60);
      game.modulesThisWave = 0;
      game.waveTarget = 10 + Math.floor(game.wave * 1.4);
      game.spawnTimer = 0;
    };

    // Toggle auto-connect
    window.toggleAutoConnect = function() {
      game.autoConnect = !game.autoConnect;
      const btn = document.getElementById('autoConnectBtn');
      btn.textContent = game.autoConnect ? 'Auto-Connect: ON' : 'Auto-Connect: OFF';
    };

    // Reset game
    window.resetGame = function() {
      game.xp = 0;
      game.wave = 0;
      game.running = false;
      game.modules = [];
      game.moduleId = 0;
      game.player = { x: 100, y: 100, r: 14, speed: 240 };
      
      document.getElementById('xp').textContent = '0';
      document.getElementById('wave').textContent = '0';
      document.getElementById('startBtn').disabled = false;
      document.getElementById('startBtn').textContent = 'Start Game';
      document.getElementById('gameOverModal').classList.remove('active');
    };

    // Spawn module
    function spawnModule() {
      const side = Math.random();
      let x, y, vx, vy;

      if (side < 0.25) {
        x = -20;
        y = Math.random() * (game.canvas.height - 80) + 40;
        vx = Math.random() * 0.8 + 0.4;
        vy = Math.random() * 0.6 - 0.3;
      } else if (side < 0.5) {
        x = Math.random() * (game.canvas.width - 80) + 40;
        y = -20;
        vx = Math.random() - 0.5;
        vy = Math.random() * 0.8 + 0.4;
      } else if (side < 0.75) {
        x = game.canvas.width + 20;
        y = Math.random() * (game.canvas.height - 80) + 40;
        vx = -(Math.random() * 0.8 + 0.4);
        vy = Math.random() * 0.6 - 0.3;
      } else {
        x = Math.random() * (game.canvas.width - 80) + 40;
        y = game.canvas.height + 20;
        vx = Math.random() - 0.5;
        vy = -(Math.random() * 0.8 + 0.4);
      }

      const badChance = Math.min(0.08 + game.wave * 0.02 + Math.random() * 0.1, 0.6);
      const type = Math.random() < badChance ? 'bad' : 'good';

      game.modules.push({
        id: ++game.moduleId,
        x, y, vx, vy, type,
        connected: false
      });
      game.modulesThisWave++;
    }

    // Try to connect to module
    function tryConnect(module) {
      if (module.connected) return;

      const dist = Math.hypot(module.x - game.player.x, module.y - game.player.y);
      if (dist > CONNECT_DIST * 2 && !game.autoConnect) return;

      if (module.type === 'good') {
        module.connected = true;
        game.xp += XP_GAIN;
        document.getElementById('xp').textContent = game.xp;
        
        setTimeout(() => {
          const idx = game.modules.findIndex(m => m.id === module.id);
          if (idx >= 0) game.modules.splice(idx, 1);
        }, 200);
      } else {
        game.xp -= XP_LOSS;
        document.getElementById('xp').textContent = game.xp;
        
        if (game.xp < 0) {
          endGame();
          return;
        }
        
        setTimeout(() => {
          const idx = game.modules.findIndex(m => m.id === module.id);
          if (idx >= 0) game.modules.splice(idx, 1);
        }, 200);
      }
    }

    // Check collisions
    function checkCollisions() {
      for (let i = game.modules.length - 1; i >= 0; i--) {
        const m = game.modules[i];
        if (m.type === 'bad') {
          const dist = Math.hypot(m.x - game.player.x, m.y - game.player.y);
          if (dist < COLLIDE_DIST + game.player.r) {
            game.xp -= XP_LOSS;
            document.getElementById('xp').textContent = game.xp;
            game.modules.splice(i, 1);
            
            if (game.xp < 0) {
              endGame();
            }
          }
        }
      }
    }

    // End game
    function endGame() {
      game.running = false;
      document.getElementById('finalXP').textContent = game.xp;
      document.getElementById('finalWave').textContent = game.wave;
      document.getElementById('gameOverModal').classList.add('active');
      document.getElementById('startBtn').disabled = false;
      document.getElementById('startBtn').textContent = 'Start Game';
      saveScore();
    }

    // Input handlers
    function handleKeyDown(e) {
      game.keys[e.key.toLowerCase()] = true;
      if (e.code === 'Space') {
        e.preventDefault();
        connectNearby();
      }
    }

    function handleKeyUp(e) {
      game.keys[e.key.toLowerCase()] = false;
    }

    function handleCanvasClick(e) {
      const rect = game.canvas.getBoundingClientRect();
      const mx = (e.clientX - rect.left) * (game.canvas.width / rect.width);
      const my = (e.clientY - rect.top) * (game.canvas.height / rect.height);

      let nearest = null;
      let bestDist = 9999;

      for (const m of game.modules) {
        const d = Math.hypot(m.x - mx, m.y - my);
        if (d < bestDist) {
          bestDist = d;
          nearest = m;
        }
      }

      if (nearest && bestDist < 70) {
        tryConnect(nearest);
      }
    }

    function connectNearby() {
      let nearest = null;
      let bestDist = 9999;

      for (const m of game.modules) {
        if (m.connected) continue;
        const d = Math.hypot(m.x - game.player.x, m.y - game.player.y);
        if (d < bestDist) {
          bestDist = d;
          nearest = m;
        }
      }

      if (nearest && bestDist <= CONNECT_DIST * 2) {
        tryConnect(nearest);
      }
    }

    // Game loop
    function gameLoop(now) {
      const dt = (now - game.lastTime) / 1000;
      game.lastTime = now;

      // Move player
      let vx = 0, vy = 0;
      if (game.keys['arrowleft'] || game.keys['a']) vx = -1;
      if (game.keys['arrowright'] || game.keys['d']) vx = 1;
      if (game.keys['arrowup'] || game.keys['w']) vy = -1;
      if (game.keys['arrowdown'] || game.keys['s']) vy = 1;

      if (vx || vy) {
        const len = Math.hypot(vx, vy) || 1;
        game.player.x += (vx / len) * game.player.speed * dt;
        game.player.y += (vy / len) * game.player.speed * dt;
        game.player.x = Math.max(20, Math.min(game.canvas.width - 20, game.player.x));
        game.player.y = Math.max(20, Math.min(game.canvas.height - 20, game.player.y));
      }

      // Spawn modules
      if (game.running && game.modulesThisWave < game.waveTarget) {
        game.spawnTimer += dt * 1000;
        if (game.spawnTimer >= game.spawnInterval) {
          spawnModule();
          game.spawnTimer = 0;
        }
      }

      // Update modules
      for (const m of game.modules) {
        m.x += m.vx * (50 + game.wave * 6) * dt;
        m.y += m.vy * (50 + game.wave * 4) * dt;
        m.vx += (Math.random() - 0.5) * 0.04;
        m.vy += (Math.random() - 0.5) * 0.04;
      }

      // Auto-connect
      if (game.autoConnect) {
        for (const m of game.modules) {
          if (!m.connected && m.type === 'good') {
            const d = Math.hypot(m.x - game.player.x, m.y - game.player.y);
            if (d < CONNECT_DIST + 6) tryConnect(m);
          }
        }
      }

      // Check collisions
      checkCollisions();

      // Clean up distant modules
      game.modules = game.modules.filter(m =>
        m.x > -80 && m.x < game.canvas.width + 80 &&
        m.y > -80 && m.y < game.canvas.height + 80
      );

      // Check wave completion
      if (game.running && game.modulesThisWave >= game.waveTarget && game.modules.length === 0) {
        game.running = false;
        game.xp += 20 + game.wave * 3;
        document.getElementById('xp').textContent = game.xp;
        document.getElementById('startBtn').disabled = false;
        document.getElementById('startBtn').textContent = 'Next Wave';
        saveScore();
      }

      // Draw
      draw();

      requestAnimationFrame(gameLoop);
    }

    // Draw game
    function draw() {
      const ctx = game.ctx;
      const canvas = game.canvas;

      // Background
      ctx.fillStyle = COLORS.bg;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Grid
      ctx.strokeStyle = 'rgba(0, 255, 136, 0.06)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += 40) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += 40) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // Draw modules
      for (const m of game.modules) {
        if (m.connected) continue;

        // Outer glow
        ctx.beginPath();
        ctx.fillStyle = m.type === 'good' ? COLORS.good : COLORS.bad;
        ctx.shadowColor = ctx.fillStyle;
        ctx.shadowBlur = 20;
        ctx.arc(m.x, m.y, 16, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Inner circle
        ctx.beginPath();
        ctx.fillStyle = '#000';
        ctx.arc(m.x, m.y, 8, 0, Math.PI * 2);
        ctx.fill();

        // Symbol
        ctx.fillStyle = m.type === 'good' ? COLORS.good : COLORS.bad;
        ctx.font = 'bold 16px sans-serif';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(m.type === 'good' ? '+' : '!', m.x, m.y);
      }

      // Draw player core
      const p = game.player;
      ctx.beginPath();
      ctx.fillStyle = COLORS.core;
      ctx.shadowColor = COLORS.core;
      ctx.shadowBlur = 30;
      ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Inner core
      ctx.beginPath();
      ctx.fillStyle = '#000';
      ctx.arc(p.x, p.y, p.r * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }
  </script>
</body>
</html>
